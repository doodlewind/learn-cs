# 结构体与堆

在上一节的最后，我们已经演示了指针和引用传递的作用，但示例所用的 JavaScript 代码中所涉及的对象，在 C 语言中有什么对应的概念呢？让我们从结构体开始吧。


## struct 语法
对象最基本的用途之一，是封装若干种相互关联的数据。我们可以用结构体来定义这样的数据结构。假设我们在 [struct.c](./struct.c) 里需要一个具备宽度和高度属性的“矩形”概念，就可以定义出相应的结构体：

``` c
struct Rect {
  float width;
  float height;
};
```

基本的使用也很符合直觉：

``` c
struct Rect rect;
rect.width = 16.0;
rect.height = 9.0;

printf("Size: %f - %f\n", rect.width, rect.height);
```

我们可以用 `typedef` 语法来简化声明和使用：

``` c
typedef struct {
  float width;
  float height;
} Rect;

// ...
Rect rect;
```


## 堆内存
到目前为止，我们所声明的变量都是分配在调用栈上的，栈上分配的变量会在函数调用结束时被自动回收，很多场景下这是一个强大而优雅的特性。但如果单纯基于这个特性，我们难以**在应用的多个函数之间之间复用较大的一段内存空间**。尤其在我们需要使用较大的结构体数据的场景下，每次函数调用时将整个结构体复制一份传入的方式也存在着性能问题。

我们已经提及过，基于指针和引用传递方式，我们能够将函数调用时参数的全量复制优化为对指针的传递。但这时我们会遇到另一个麻烦：对于在函数中声明的局部变量，我们不应该返回指向它们的指针：局部变量会在函数调用结束后被回收，故而指向它们的指针，其内容可能被覆写。在 [return-local.c](./return-local.c) 中，我们在函数里初始化了一个结构体，再将指向它的指针返回。它虽然在简单的示例场景下能够运行，但编译时会产生一个警告。

有没有不受调用栈机制控制的内存空间呢？这就是所谓的**堆内存**了。我们一般使用**缓冲区**的概念来表达这样的一段内存空间。在 C 语言中，我们可以使用 `malloc` 函数分配堆内存，并用 `free` 函数释放之：

``` c
// ...
Rect *rect;
rect = malloc(sizeof(Rect));

// 对指向结构体的指针，可用 `->` 替代 `.` 来获取其成员
rect->width = 16.0;
// ...

free(rect);
rect = NULL;
```

在 [buffer-alloc.c](./buffer-alloc.c) 中我们可以看到对于堆内存的使用示例：在函数中动态地分配堆内存空间，这样声明的缓冲区不会在函数调用结束后被回收。但由于 C 语言没有垃圾收集机制，我们需要手动管理内存，故而这时保存在堆内存上的结构体需要通过 `free` 来释放。

这就是结构体与堆内存的基本概念了。在 C 语言中，手动的内存管理很容易造成内存泄漏。另一方面，结构体适合存取纯粹的数据，难以与函数相关联，实现这样的语法：

``` c
rect.getSize();
rect.rotate();
```

这就是面向对象的编程语言所要解决的问题了，而结构体则正是对象的雏形。
